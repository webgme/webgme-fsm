/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 0.14.0 from webgme on Wed Nov 04 2015 09:50:47 GMT-0600 (Central Standard Time).
 */

define([
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'text!./metadata.json'
], function (
    PluginConfig,
    PluginBase,
    pluginMetadata) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of FSMImporter.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin FSMImporter.
     * @constructor
     */
    var FSMImporter = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;

    };

    FSMImporter.metadata = pluginMetadata;

    // Prototypal inheritance from PluginBase.
    FSMImporter.prototype = Object.create(PluginBase.prototype);
    FSMImporter.prototype.constructor = FSMImporter;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    FSMImporter.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            currentConfig = self.getCurrentConfig();

        if (!currentConfig.file) {
            callback(new Error('No file provided.'), self.result);
            return;
        }

        self.blobClient.getObjectAsJSON(currentConfig.file, function (err, dataModel) {
            if (err) {
                callback(err, self.result);
                return;
            }

            self.logger.info('Obtained dataModel', dataModel);
            self.buildUpStateMachine(dataModel, function (err) {
                if (err) {
                    callback(err, self.result);
                    return;
                }

                self.save('FSM Importer created new model.', function (err) {
                    if (err) {
                        callback(err, self.result);
                        return;
                    }

                    self.result.setSuccess(true);
                    callback(null, self.result);
                });
            })
        });
    };

    FSMImporter.prototype.buildUpStateMachine = function(dataModel, callback) {
        var self = this,
            smData = dataModel.stateMachine,
            i, j,
            idToNode = {},
            stateNode,
            transNode,
            stateId,
            transitions = [],
            smNode;

        // Create the stateMachine
        smNode = self.core.createNode({
            parent: self.rootNode,
            base: self.META.UMLStateDiagram
        });

        self.core.setAttribute(smNode, 'name', smData.name);
        self.core.setRegistry(smNode, 'position', {x: 200, y: 200});

        // Create the states and gather data about the transitions
        for (i = 0; i < smData.states.length; i += 1) {
            stateId = smData.states[i].id;
            if (stateId === smData.initialState) {
                stateNode = self.core.createNode({
                    parent: smNode,
                    base: self.META.Initial
                });
            } else if (smData.finalStates.indexOf(stateId) > -1) {
                stateNode = self.core.createNode({
                    parent: smNode,
                    base: self.META.End
                });
            } else {
                stateNode = self.core.createNode({
                    parent: smNode,
                    base: self.META.State
                });
            }

            self.core.setAttribute(stateNode, 'name', smData.states[i].name);
            self.core.setRegistry(smNode, 'position', {x: 50 + (100 * i), y: 200}); // This could be more fancy.

            // Add the node with its old id to the map (will be used when creating the transitions)
            idToNode[stateId] = stateNode;

            // Gather the outgoing transitions from the current state and store the info.
            for (j = 0; j < smData.states[i].transitions.length; j += 1) {
                transitions.push({
                    src: stateId,
                    dst: smData.states[i].transitions[j].targetId,
                    event: smData.states[i].transitions[j].event
                });
            }
        }

        // With all state created, we will now create the transitions and connect them between the states.
        for (i = 0; i < transitions.length; i += 1) {
            transNode = self.core.createNode({
                parent: smNode,
                base: self.META.Transition
            });

            self.core.setAttribute(transNode, 'event', transitions[i].event);

            self.core.setPointer(transNode, 'src', idToNode[transitions[i].src]);
            self.core.setPointer(transNode, 'dst', idToNode[transitions[i].dst]);
        }

        callback(null);
    };

    return FSMImporter;
});